{"name":"Events","body":"Events provide an event dispatcher with various ways of listening to events.\r\n\r\n    $dispatcher = new Events\\EventDispatcher();\r\n\r\n    $dispatcher->on('car.forward', function($e) {\r\n        echo \"The car is goind forward\";\r\n    });\r\n\r\n    $dispatcher->notify(new Events\\Event(null, 'car.forward'));\r\n\r\nCheck out [example.php](https://github.com/maximebf/events/blob/master/example.php) for a complete example.\r\n\r\n# Installation\r\n\r\nThe easiest way to install Events is using [Composer](https://github.com/composer/composer)\r\nwith the following requirement:\r\n\r\n    {\r\n        \"require\": {\r\n            \"maximebf/events\": \">=0.1.0\"\r\n        }\r\n    }\r\n\r\nAlternatively, you can [download the archive](https://github.com/maximebf/events/zipball/master) \r\nand add the lib/ folder to PHP's include path:\r\n\r\n    set_include_path('/path/to/lib' . PATH_SEPARATOR . get_include_path());\r\n\r\nEvents does not provide an autoloader but follows the [PSR-0 convention](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md).  \r\nYou can use the following snippet to autoload Events classes:\r\n\r\n    spl_autoload_register(function($className) {\r\n        if (substr($className, 0, 6) === 'Events') {\r\n            $filename = str_replace('\\\\', DIRECTORY_SEPARATOR, trim($className, '\\\\')) . '.php';\r\n            require_once $filename;\r\n        }\r\n    });\r\n\r\n# Listening to events\r\n\r\nEvents are notified through the `Events\\EventDispatcher` class. The easiest way to register\r\nlisteners to handle events is using the `on()` method:\r\n\r\n - `on($event_name, $callback)`: listens to event with the specified name, the wildcard (`*`) character can be used\r\n - `on($regexp, $callback)`: listens to event which name matches the regexp\r\n - `on($callback)`: listens to all events\r\n - `on($classname)`: listens using a class an \"on\" methods (see below)\r\n\r\n`$callback` can be any PHP callable (ie. a callback - string or array - or a closure). It will\r\nreceive an `Events\\Event` object as its only argument.\r\n\r\n    $dispatcher->on('car.forward', function($e) {});\r\n    $dispatcher->on('car.*', function($e) {});\r\n    $dispatcher->on('/^car\\.(.+)$/', function($e) {});\r\n    $dispatcher->on(function($e) {});\r\n\r\nWhen using `on($classname)` the class should have methods named with the camelized event\r\nname prefixed witn \"on\". eg: the method `onCarForward()` would listen to event named\r\ncar.forward (or car_forward or car-forward).\r\n\r\n    class CarListener {\r\n        public function onCarForward($e) {}\r\n    }\r\n\r\n    $dispatcher->on(new CarListener());\r\n\r\nMultiple listeners can listen to the same event. However, some of them may be more\r\nimportant than others. This can be specified using an integer as the third parameter \r\nto the `on()` method. The higher, the more important.\r\n\r\n    $dispatcher->on('car.forward', function($e) {}, 100);\r\n\r\nEvents are made of a sender, a name and some parameters.\r\nThe event object has the following methods:\r\n\r\n - `getSender()`: returns the object that emitted the event\r\n - `getName()`: returns the event's name\r\n - `getParam($name, $default=null)`: returns the $name parameter\r\n - `getParams()`\r\n\r\nFor some events a return value may be needed. Listeners can specify a return value \r\nusing `setReturnValue($value)`.\r\n\r\nSome events may allow the action they represent to be cancelled. This can be perform\r\nusing `cancel()`.\r\n\r\nFinally, if multiple listeners handle an event, on of them can stop the event from\r\npropagating to the other one using `stopPropagation()`.\r\n\r\n    $dispatcher->on('method_call', function($e) {\r\n        if ($e->getParam('method_name') === 'foobar') {\r\n            $e->cancel();\r\n        } else {\r\n            $e->setReturnValue(true);\r\n        }\r\n    });\r\n\r\nUnder the hood, when the `on()` method is called, the event dispatcher creates a\r\nlistener object of type `Events\\EventListener`. You can create custom listener\r\nobjects and add them using `addListener()`.\r\n\r\n# Dispatching events\r\n\r\nEvents can be dispatched using the `notify($event)` method of the event dispatcher.\r\nThe event must be an object of type `Events\\Event`.\r\n\r\n    $dispatcher->notify(new Events\\Event($sender, $name, $params));\r\n\r\n`notify()` returns a boolean indicating if the event has been processed by one or more\r\nlisteners.\r\n\r\nIf you want to ensure that your event is delivered to at leadt one listener, you can\r\nuse `notifyUntil($event, $callback=null)`. This method will try to deliver the event\r\nand if that fails, will try with any listeners added in the future. `$callback` will\r\nbe called once the event has been processed.\r\n\r\n    $dispatcher->notifyUntil(new Events\\Event(null, 'foo'), function() {\r\n        echo \"Event processed!\";\r\n    });\r\n\r\nTo ease the process of notifying events, an `Events\\Notifier` object can be used to\r\ncreate and dispatch events. Its constructor takes an event dispatcher and the sender\r\nobject as mandatory arguments. You can optionaly provide a prefix for event names \r\nand specify a different event class to use. `notify()` and `notifyUntil()` are both\r\navailable but under a different form. Instead of taking an event object, they take\r\nthe name of the event and optionaly and array of params.\r\n\r\n    $notifier = new Events\\Notifier($eventDispatcher, $sender);\r\n    $notifier->notify('foobar', array('param1' => 'value'));\r\n\r\n# Other utilities\r\n\r\nYou can use `Events\\GenericEmitter` to create objects which emits event and on which\r\nlisteners can be registered.\r\n\r\n    class Car extends Events\\GenericEmitter {\r\n        protected $eventPrefix = 'car.';\r\n        public function forward() {\r\n            $this->notify('forward');\r\n        }\r\n    }\r\n\r\n    $car = new Car();\r\n    $car->on('car.forward', function($e) {});\r\n\r\nEvents emitter can act as relay. Thus if you have a global event dispatcher, events\r\nof a specific emitter could be relayed by adding the later as a listener to the former:\r\n\r\n    $car = new Car();\r\n    $dispatcher = new Events\\EventDispatcher();\r\n\r\n    $car->on('car.forward', function($e) {});\r\n    $dispatcher->on('car.forward', function($e) {});\r\n\r\n    $car->addListener($dispatcher);\r\n\r\nThe `Events\\EventProxy` class can be used as proxy to any objects and will emit events\r\nwhenever a property is accessed or a method is called.\r\n\r\n    $object = new Events\\EventProxy(new MyClass(), $dispatcher);\r\n    $dispatcher->on('proxy.call', function($e) {\r\n        if ($e->getParam('method') === 'foobar') {\r\n            echo \"Foobar was called!\";\r\n        }\r\n    });\r\n    $object->foobar();\r\n\r\nYou can create custom event listeners by implementing the `Events\\EventListener` interface.\r\n\r\n    class CustomListener implements Events\\EventListener {\r\n        public function match(Event $e) {\r\n            // checks if the event can be handled by this listener\r\n            return $e->getName() === 'foobar';\r\n        }\r\n        public function handle(Event $e) {\r\n            // do something with $e when match() returned true\r\n            echo $e->getName();\r\n        }\r\n    }\r\n\r\n    $dispatcher->addListener(new CustomListener());","tagline":"Events library for PHP 5.3+","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}